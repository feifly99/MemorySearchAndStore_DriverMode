Overall：

           目前支持功能：
           驱动级内存遍历；
           内存搜索（精确值搜索/变大的数值/变小的数值/未变动的数值）；
           进程模块遍历；
           进程线程遍历；
           强行写入内存；
           进程隐藏；
           进程傀儡；
           SSDT inline hook；
           进程保护（基于SSDT hook）
           获取DLL导出函数的相关信息：
           （以名字）导出的函数个数；
           导出函数名字；
           导出函数地址.

           经测试，所有功能调用都没有内存泄露出现
2024/9/26：

           使用了SSDT Hook来实现进程保护，但是目前没有整理成函数；
           //危险：卸载部分为了快速测试采用了硬编码！
           //实际应用目前只能在我的电脑上，别的机器用100%会蓝屏！！但暂时先不改了！
           思路：刚开始在想用我自己定义的hook函数减去SSDT表头，用差值去替换偏移；
           但是上面得出差值是0x42849650，由于64位系统对NT函数寻址进行了一个小加密，需要把偏移二进制右移动4位；
           即：SSDT_BASE[index] + SSDT_BASE = funcAddressOf[index]
           导致了我的差值不能直接写在偏移地址里面，差了“半个”字节，无法解决此问题！
           然后我又发现NtOpenProcess函数上方有13个字节是0xCC，而我一计算：
           mov rax, 0FFFFF8056B0C7BA0h -> 48 b8 60 12 32 86 06 f8 ff ff 
           jmp rax                     -> ff e0            
           反汇编机器码发现是12个字节，恰好能被容纳进去！！！
           因此我就动手在NtOpenProcess函数上方的13个字节篡改成了我的目标机器码；
           //危险：由于XP之后微软对SSDT相关的内存严格保护；
           //在修改之前需要先变更CR0寄存器的第16位二进制位来破除写保护！
           然后再把*(ULONG*)(SSDT_BASE[index])篡改成我的shellcode的起始地址偏移；
           即：*(ULONG*)(SSDT_BASE[index]) = MyNtOpenProcess - SSDT_BASE;
           再把这个值shl 4，多出来的半个字节换成什么都可以！
           就实现了基于SSDT的inline hook！
           测试表明，驱动程序运行时，使用CE打开进程会提示无法打开！
           表明CPU确实执行到了我自己定义的ntopenprocess了！
2024/9/24：

           驱动先更新到这儿！还有用户层接口，还要忙开题，暂时挂起此项目；
           挂起之后的主题是软硬件断点、驱动DLL注入和inline hook.
2024/9/21：

           补充了两个三个汇编过程，可以根据模块加载的基地址获得：
           1.此模块以名字导出的函数的个数；
           2.第j个导出函数的名字；
           3.第j个导出函数的地址。
2024/9/20：

           补全了进程隐藏和进程傀儡两个功能和用户层交互的代码；
           遇到了新的蓝屏代码：KERNEL_SECURITY_CHECK_FAILURE：
           原因可能是傀儡进程之后没进行链表修复导致过不了关机前的机器检查；
           因此加更，现在执行___UNLOAD_DRIVER_PREPARE___逻辑会自动判断并恢复恢复所有隐藏和伪装的进程。
           对隐藏进程和傀儡进程的结构采用了双向链表，经测试没有蓝屏和内存泄漏问题出现。
24/9/19深夜补档：

           补全了驱动程序目前为止的所有逻辑，支持驱动级内存写入。
           测试时发现两个问题：
           1.内存大量泄露.
           RSL链表某个节点断链时需要释放掉原来这个节点的buffer成员的内存；
           并且在不断链时要释放掉原来的内存并重新分配新字符串长度的内存；
           之前一个版本忘记了，导致了内存池为DDDD（RSL结构的buffer成员标号）的内存出现了大量泄漏，现在已经解决。
           2.蓝屏代码：INVALID_KERNEL_HANDLE.
           这个问题是由于驱动程序中关闭了文件句柄后没有将其置为NULL；
           导致用户层多次调用___UNLOAD_DRIVER_PREPARE___重复执行了ZwClose(g_kernelProcess)过程；
           这访问了已经被释放的内存从而导致了系统蓝屏，现在已经解决。
           目前驱动可以在OS:Windows x64 22H2/CPU:I7-9750H架构下驱动平稳运行，不会蓝屏；
           并且支持反复测试，在启动驱动之后用户层可以反复调用驱动程序，不必调用一次卸载一次；
           而且经过半小时测试也没有内存泄漏现象出现，驱动大体框架已经完工。
2024/9/19：

           对链表重新进行了整理，之前的版本是新建一个链表并释放原来的链表；
           新版本是直接对老链表进行节点移除，定义了虚拟链表头来辅助移除节点；
           改完之后对于大型应用程序的搜索效率更加高效。
2024/9/18：

           再一次重构了IOCTL逻辑，重新定义了RSL结构体来进行对比搜索；
           目前驱动的大多数基本功能都已经实现，包括
           内存遍历，内存查找，内存更改，进程隐藏，模块遍历，模块隐藏，寄存器读取；
           内存查找模式支持首次搜索，精确值搜索，变大的数值，变小的数值，未改变的数值；
           数值变动基于远端字节判断方法；
           在OS:Windows x64 22H2/CPU:I7-9750H架构下驱动平稳运行，不会蓝屏，所有的内存块都没有内存泄漏；
           不会蓝屏，不会内存泄漏，没有死锁/死循环风险；
           几乎对所有可能蓝屏/内存泄漏/死循环的地方都进行了严格的条件检查；
           接下来的工作：整理并优化驱动代码结构/构建用户层应用程序进行交互；
           其他开发中的功能：抹PE头，断链，PID篡改，PE特征修改。
2024/9/16：
           
           重构了IOCTL的屎山！逻辑更清晰，支持多次查找和继续查找；
           删除了大量的宏定义和typedef,增加可读性；
           六块分页内存没有一丁点泄露，所有内存和句柄都被正确释放，基于poolmon.exe检测得出；
           但首次引用了全局变量，正在准备开往第二座屎山。。。。
2024/9/12：

           IOCTL驱动处理已经快写成屎山了。还出现了一个内存泄漏，但是那个内存泄漏已经解决了；
           泄露原因在于释放单链表操作最后一个节点没释放；
           Driver_User_IO_Interaction_Entry早晚得重构，不能在屎山上一直拉屎。
2024/9/11：

           新增了内核层和用户层的交互，支持用户层传递结构体到驱动；
           目前支持内存遍历，字符串搜索，遍历进程的全部线程和全部模块，写入内存。
2024/9/10：

           修改了模块遍历，之前由于_LDR_DATA_TABLE_ENTRY结构和_PEB_LDR_DATA弄混了导致偏移量错误导致了不能正确地导出模块地址；
           新增了强行写内存，基于修改控制寄存器CR0实现；
           知道了KdBreakPoint怎么和Windbg交互了。
2024/9/9：

           修复了关机蓝屏的BUG，正确地释放了引用计数。
2024/9/8：

           新增进程模块遍历，基于PEB->LDR->InLoadOrderModuleListAddress硬编码指针实现。
2024/9/7：

           新增进程隐藏，基于断PE链实现。
2024/9/3：

           驱动正常运行，但是一关机就会蓝屏，蓝屏代码为REFERENCE_BY_POINTER。
